var documenterSearchIndex = {"docs":
[{"location":"interfaces.html#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"This page lists the different interfaces that need to be implemented to run StochasticSeriesExpansion.jl with custom models or estimators. Their purpose is to translate the information of a physical model into a representation that the SSE algorithm can understand.","category":"page"},{"location":"interfaces.html#abstract_model","page":"Interfaces","title":"Model interface","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"The AbstractModel model interface describes a Hamiltonian that can be simulated with StochasticSeriesExpansion.jl. See Available models to see the available example implementations. ","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"AbstractModel\nStochasticSeriesExpansion.generate_sse_data\nStochasticSeriesExpansion.get_opstring_estimators\nStochasticSeriesExpansion.leg_count\nStochasticSeriesExpansion.normalization_site_count","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.AbstractModel","page":"Interfaces","title":"StochasticSeriesExpansion.AbstractModel","text":"The type used to define models that can be simulated by StochasticSeriesExpansion.jl.\n\nModels are expected to have a constructor\n\nYourModel(parameters::AbstractDict{Symbol, <:Any})\n\nthat gets passed the Carlo.jl task parameters that can be used to describe all parameters of your model, such as the lattice or the coupling strengths.\n\nApart from this, methods for the following functions should be implemented:\n\ngenerate_sse_data\nget_opstring_estimators\nleg_count\nnormalization_site_count\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.generate_sse_data","page":"Interfaces","title":"StochasticSeriesExpansion.generate_sse_data","text":"generate_sse_data(model::YourModel) -> SSEData\n\nThis function should translate the data saved in the model to construct the information needed by the abstract-loop SSE algorithm:\n\na graph of bonds\nthe bond Hamiltonians\n\nFrom this information an SSEData instance can be constructed and returned.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.get_opstring_estimators","page":"Interfaces","title":"StochasticSeriesExpansion.get_opstring_estimators","text":"get_opstring_estimators(model::YourModel) -> Vector{Type{<:AbstractOpstringEstimator}}\n\nReturns an array of types of operator string estimators that are used to calculate most observables. Each of them should implement the Operator string estimator interface.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.leg_count","page":"Interfaces","title":"StochasticSeriesExpansion.leg_count","text":"leg_count(model::Type{YourModel}) -> Int\n\nThis function returns the maximum number of legs a bond operator can have in the model.\n\nIn the SSE algorithm, the Hamiltonian is decomposed into bond operators that (ideally) act on only a few sites. For example, the Heisenberg model consists of operators that act on two sites. In a diagrammatic picture, each site corresponds to one incoming and one outgoing leg. Therefore, the leg count in the Heisenberg model is four.\n\nOperators with differing leg-counts are supported within the same model. In such cases, leg_count should return the maximum.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.normalization_site_count","page":"Interfaces","title":"StochasticSeriesExpansion.normalization_site_count","text":"normalization_site_count(model::YourModel) -> Int\n\nThe number of physical sites used for normalizing observables. It may differ from the SSE algorithmic site count sometimes, e.g. when the computational basis consists of multiple physical spins but we still want the energy to be measured per spin.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#abstract_opstring_estimator","page":"Interfaces","title":"Operator string estimator interface","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"The AbstractOpstringEstimator interface is used to implement most observable estimators in StochasticSeriesExpansion.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"AbstractOpstringEstimator\nStochasticSeriesExpansion.init\nStochasticSeriesExpansion.measure\nStochasticSeriesExpansion.result\nStochasticSeriesExpansion.register_evaluables","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.AbstractOpstringEstimator","page":"Interfaces","title":"StochasticSeriesExpansion.AbstractOpstringEstimator","text":"This interface allows defining observable estimators that act on each operator of the the SSE operator string. The measurement code will call the functions of this interface like the following. However, for efficiency reasons, multiple estimators are automatically fused into a single loop.\n\nest = init(YourEstimator, model, state)\nfor op in operators\n    if isidentity(op)\n        continue\n    end\n\n    if !isdiagonal(op)\n        # update state\n    end\n\n    if n < num_operators\n        measure(est, op, state, sse_data)\n    end\n    n += 1\nend\n\nresult(est, mccontext, T, sign)\n\nHowever, in practice, StochasticSeriesExpansion will interlace different estimators into the same loop for efficiency.\n\nA reference implementation is in the model-generic MagnetizationEstimator, which can be used for most magnetization-like observables.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.init","page":"Interfaces","title":"StochasticSeriesExpansion.init","text":"init(::Type{YourOpstringEstimator},\n     model::AbstractModel,\n     state::AbstractVector{<:StateIdx}) -> YourOpstringEstimator\n\nConstructs an opstring estimator based on a model and an initial state. The state is a vector of integers labelling the computational site basis states. The estimator needs to interpret them in terms of physical quantities.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.measure","page":"Interfaces","title":"StochasticSeriesExpansion.measure","text":"measure(est, op::OperCode, state::AbstractVector{<:StateIdx}, sse_data::SSEData)\n\nPerform the in-string measurement of estimator est on each operator op in the operator string. The state at the current position and the sse_data object are passed for additional reference.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.result","page":"Interfaces","title":"StochasticSeriesExpansion.result","text":"result(est, ctx::Carlo.MCContext, T::AbstractFloat, sign::AbstractFloat)\n\nFinalize the measurement by saving the results to the Carlo MCContext, e.g. by calling measure!(ctx, :Magnetization, est.mag). For more information, consult the Carlo documentation.\n\nFor some observables, knowing the temperature T is necessary. In the case of a signful simulation, sign != 1 should be taken into account.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.register_evaluables","page":"Interfaces","title":"StochasticSeriesExpansion.register_evaluables","text":"register_evaluables(::Type{<:YourOpstringEstimator}, eval::Carlo.Evaluator, params::AbstractDict)\n\nOperator string estimators est can define their own evaluables using this function, which passes a Carlo.Evaluator and the task parameters. The state of the estimator is unavailable here since this runs in the postprocessing step.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#MagnetizationEstimator","page":"Interfaces","title":"MagnetizationEstimator","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"A useful general purpose implementation of the operator string estimator interface is the MagnetizationEstimator which works for all models that have some kind of magnetization.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"MagnetizationEstimator\nmagnetization_state\nmagnetization_lattice_site_idx\nmagnetization_estimator_standard_prefix","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.MagnetizationEstimator","page":"Interfaces","title":"StochasticSeriesExpansion.MagnetizationEstimator","text":"MagnetizationEstimator{\n    OrderingVector,\n    StaggerUC,\n    Model,\n    Prefix,\n    Dimension} <: AbstractOpstringEstimator\n\nGeneric operator string estimator that can be used for all models that have\n\na field lattice::Lattice{Dimension}\nimplement magnetization_state.\n\noptionally, magnetization_lattice_site_idx.\n\nIt computes the\n\n:Mag, magnetization langle mrangle\n:AbsMag, absolute magnetization langle mrangle\n:Mag2, squared magnetization langle m^2rangle\n:Mag4, quartic magnetization langle m^4rangle\n:MagChi, susceptibility N int_0^beta dtau langle m(tau) mrangle\n:BinderRatio, Binder ratio langle m^2rangle^2langle m^4rangle\n\nHere, m = frac1N sum_i m_i,the m_i are given by magnetization_state and N is returned by normalization_site_count.\n\nType parameters\n\nOrderingVector: Fourier component to compute in units of π. For example (11) corresponds to (ππ)\nIf StaggerUC is true, the sublattice sign of the unitcell is additionally taken into account.\nModel: model type to apply this estimator to.\nPrefix: (Symbol) this prefix is added to all observable names. Consider using magnetization_estimator_standard_prefix.\nDimension: dimension of the underlying lattice.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_state","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_state","text":"magnetization_state(model::AbstractModel, site_idx, state_idx)\n\nThis interface needs to be implemented by any model that wants to use MagnetizationEstimator. \n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_lattice_site_idx","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_lattice_site_idx","text":"magnetization_lattice_site_idx(model::AbstractModel, sse_site_idx) -> Integer\n\nIn models where additional degrees of freedom exist, this function maps sse site indices to physical lattice site indices.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_estimator_standard_prefix","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_estimator_standard_prefix","text":"magnetization_estimator_standard_prefix(q::Tuple{Bool...}, stagger_uc::Bool)\n\nReturns the conventional prefix for a magnetization estimator with ordering vector q and stagger_uc set.\n\n\n\n\n\n","category":"function"},{"location":"sse_data.html#Simulation-data-structure","page":"Simulation data structure","title":"Simulation data structure","text":"","category":"section"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"In order to be generic, StochasticSeriesExpansion.jl internally uses data structures that do not know a lot about physics but retain only the necessary information to run the SSE algorithm.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"If you want to implement your own models or measurements, you have to translate physics into into an SSEData object.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEData\nget_vertex_data","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEData","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEData","text":"SSEData(vertex_data::AbstractVector{<:VertexData}, bonds::AbstractVector{<:SSEBond})\n\nThis object holds everything StochasticSeriesExpansion needs to know to simulate a model using the abstract loop algorithm.\n\nThe array vertex_data contains one instance of VertexData for each distinct type of bond. The bonds define the graph of bonds along with the corresponding bond types.\n\nPublic fields\n\nbonds: the bond information passed on construction\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_vertex_data","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_vertex_data","text":"get_vertex_data(data::SSEData, bond_idx) -> VertexData\n\nThe VertexData object for a given SSE bond index bond_idx.\n\n\n\n\n\n","category":"function"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"To construct an SSEData object you need to assemble the VertexData and SSEBond objects.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEBond\nVertexData\nget_leg_state","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEBond","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEBond","text":"SSEBond(type, (i, j, ...))\n\nDefines a bond for the SSE algorithm. The type specifies which VertexData object to use. i, j are two or more site indices that are connected by a bond. This number is variable but has to be consistent across the model. If the model has bonds with different number of sites, dummy sites can be used to express lower order bonds.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.VertexData","page":"Simulation data structure","title":"StochasticSeriesExpansion.VertexData","text":"VertexData(dims::Tuple{Integer...}, bond_hamiltonian::AbstractMatrix; \n           energy_offset_factor = 0.25, tolerance = 1e-7, lp_tolerance = 1e-10)\n\nThis object holds the probability tables used for a bond in the abstract loop update algorithm.\n\ndims are the local Hilbert space dimensions of each site of the bond.\n\nbond_hamiltonian is the prod(dims)×prod(dims) matrix describing the bond Hamiltonian in the computational basis. The representation of the product Hilbert space follows the convention of LinearAlgebra.kron, so that if you have site-local operators op1, op2, kron(op1, op2) will give you a correct bond Hamiltonian.\n\nA constant is added to the bond hamiltonian so that its smallest diagonal element is\n\nmin_i(h_ii) = alpha times max_i (h_ii) - min_i (h_ii) ge 0\n\nwhere alpha is given by the parameter energy_offset_factor.\n\nMatrix elements smaller tolerance are considered zero. lp_tolerance sets the tolerance for the underlying linear programming problem.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_leg_state","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_leg_state","text":"get_leg_state(vd::VertexData, v::VertexCode)\n\nReturns the leg states (matrix elements) of the vertex v as an array of state indices.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StochasticSeriesExpansion.jl","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"An implementation of the stochastic series expansion (SSE) quantum Monte Carlo algorithm for Julia.","category":"page"},{"location":"index.html#Features","page":"StochasticSeriesExpansion.jl","title":"Features","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Run high-performance SSE simulations without being a QMC expert\nSupports anisotropic spin-S quantum Magnets out of the box\nExtensible to arbitrary models (but may suffer from sign problem)","category":"page"},{"location":"index.html#Getting-started","page":"StochasticSeriesExpansion.jl","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Jump right into the Tutorial (TODO).","category":"page"},{"location":"index.html#Can-I-simulate-my-own-model?","page":"StochasticSeriesExpansion.jl","title":"Can I simulate my own model?","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"All you need to implement is the AbstractModel interface. How well the algorithm performs in the end, depends on the model, in particular if there is a sign problem. Feel free to reach out (e.g. on Github) for assistance!","category":"page"}]
}
