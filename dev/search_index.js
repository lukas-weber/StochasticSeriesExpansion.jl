var documenterSearchIndex = {"docs":
[{"location":"sse_data.html#Simulation-data-structure","page":"Simulation data structure","title":"Simulation data structure","text":"","category":"section"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"In order to be generic, StochasticSeriesExpansion.jl internally uses data structures that do not know a lot about physics but retain only the necessary information to run the SSE algorithm. As a practicioner, you need to know about these structures either.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"If you want to implement your own models or measurements, however, it is your job to translate physics into these data structures, an SSEData object to be precise.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEData\nget_vertex_data","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEData","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEData","text":"SSEData(vertex_data::AbstractVector{<:VertexData}, bonds::AbstractVector{<:SSEBond})\n\nThis object holds everything StochasticSeriesExpansion needs to know to simulate a model using the abstract loop algorithm.\n\nThe array vertex_data contains one instance of VertexData for each distinct type of bond. The bonds define the graph of bonds along with the corresponding bond types.\n\nPublic fields\n\nbonds: the bond information passed on construction\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_vertex_data","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_vertex_data","text":"get_vertex_data(data::SSEData, bond_idx) -> VertexData\n\nThe VertexData object for a given SSE bond index bond_idx.\n\n\n\n\n\n","category":"function"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"To construct an SSEData object you need to assemble the VertexData and SSEBond objects.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEBond\nVertexData\nget_leg_state","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEBond","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEBond","text":"SSEBond(type, (i, j, ...))\n\nDefines a bond for the SSE algorithm. The type specifies which VertexData object to use. i, j are two or more site indices that are connected by a bond. This number is variable but has to be consistent across the model. If the model has bonds with different number of sites, dummy sites can be used to express lower order bonds.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.VertexData","page":"Simulation data structure","title":"StochasticSeriesExpansion.VertexData","text":"VertexData(dims::Tuple{Integer...}, bond_hamiltonian::AbstractMatrix; \n           energy_offset_factor = 0.25, tolerance = 1e-7, lp_tolerance = 1e-10)\n\nThis object holds the probability tables used for a bond in the abstract loop update algorithm.\n\ndims are the local Hilbert space dimensions of each site of the bond.\n\nbond_hamiltonian is the prod(dims)×prod(dims) matrix describing the bond Hamiltonian in the computational basis. The representation of the product Hilbert space follows the convention of LinearAlgebra.kron, so that if you have site-local operators op1, op2, kron(op1, op2) will give you a correct bond Hamiltonian.\n\nA constant is added to the bond hamiltonian so that its smallest diagonal element is\n\nmin_i(h_ii) = alpha times max_i (h_ii) - min_i (h_ii) ge 0\n\nwhere alpha is given by the parameter energy_offset_factor.\n\nMatrix elements smaller tolerance are considered zero. lp_tolerance sets the tolerance for the underlying linear programming problem.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_leg_state","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_leg_state","text":"get_leg_state(vd::VertexData, v::VertexCode)\n\nReturns the leg states (matrix elements) of the vertex v as an array of state indices.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#abstract_opstring_estimator","page":"OpstringEstimator interface","title":"OpstringEstimator interface","text":"","category":"section"},{"location":"abstract_opstring_estimator.html","page":"OpstringEstimator interface","title":"OpstringEstimator interface","text":"The AbstractOpstringEstimator interface is used to implement most observable estimators in StochasticSeriesExpansion.","category":"page"},{"location":"abstract_opstring_estimator.html","page":"OpstringEstimator interface","title":"OpstringEstimator interface","text":"AbstractOpstringEstimator\nStochasticSeriesExpansion.init\nStochasticSeriesExpansion.measure\nStochasticSeriesExpansion.result\nStochasticSeriesExpansion.register_evaluables","category":"page"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.AbstractOpstringEstimator","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.AbstractOpstringEstimator","text":"AbstractOpstringEstimator\n\nThis interface allows defining observable estimators that act on each operator of the the SSE operator string. In the combined measurement the functions of this interface are called like the following.\n\nest = init(YourEstimator, model, state)\nfor op in operators\n    if isidentity(op)\n        continue\n    end\n\n    if !isdiagonal(op)\n        # update state\n    end\n\n    if n < num_operators\n        measure(est, op, state, sse_data)\n    end\n    n += 1\nend\n\nresult(est, mccontext, T, sign)\n\nHowever, in practice, StochasticSeriesExpansion will interlace different estimators into the same loop for efficiency.\n\nA reference implementation is in the model-generic MagnetizationEstimator, which can be used for most magnetization-like observables.\n\n\n\n\n\n","category":"type"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.init","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.init","text":"init(::Type{<:AbstractOpstringEstimator}, model::AbstractModel, state::AbstractVector{<:StateIdx}) -> AbstractOpstringEstimator\n\nConstructs an opstring estimator based on a model and an initial state. The state is a vector of integers labelling the computational site basis states. The estimator needs to interpret them in terms of physical quantities.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.measure","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.measure","text":"measure(est, op::OperCode, state::AbstractVector{<:StateIdx}, sse_data::SSEData)\n\nPerform the in-string measurement of estimator est on each operator op in the operator string. The state at the current position and the sse_data object are passed for additional reference.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.result","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.result","text":"result(est, ctx::Carlo.MCContext, T::AbstractFloat, sign::AbstractFloat)\n\nFinalize the measurement by saving the results to the Carlo MCContext, e.g. by calling measure!(ctx, :Magnetization, est.mag). For more information, consult the Carlo documentation.\n\nFor some observables, knowing the temperature T is necessary. In the case of a signful simulation, sign != 1 should be taken into account.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.register_evaluables","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.register_evaluables","text":"register_evaluables(::Type{<:AbstractOpstringEstimator}, eval::Carlo.Evaluator, params::AbstractDict)\n\nOperator string estimators est can define their own evaluables using this function, which passes a Carlo.Evaluator and the task parameters. The state of the estimator is unavailable here since this runs in the postprocessing step.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html","page":"OpstringEstimator interface","title":"OpstringEstimator interface","text":"The reference implementation of this is the general purpose MagnetizationEstimator which works for all models that have some kind of magnetization.","category":"page"},{"location":"abstract_opstring_estimator.html","page":"OpstringEstimator interface","title":"OpstringEstimator interface","text":"MagnetizationEstimator\nmagnetization_state\nmagnetization_lattice_site_idx\nmagest_standard_prefix","category":"page"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.MagnetizationEstimator","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.MagnetizationEstimator","text":"MagnetizationEstimator{OrderingVector, StaggerUC, Model, Prefix, Dimension} <: AbstractOpstringEstimator\n\nGeneric operator string estimator that can be used for all models that have\n\na field lattice::Lattice\nimplement magnetization_state.\n\noptionally, magnetization_lattice_site_idx.\n\nIt computes the\n\n:Mag, magnetization langle mrangle\n:AbsMag, absolute magnetization langle mrangle\n:Mag2, squared magnetization langle m^2rangle\n:Mag4, quartic magnetization langle m^4rangle\n:MagChi, susceptibility N int_0^beta dtau langle m(tau) mrangle\n:BinderRatio, Binder ratio langle m^2rangle^2langle m^4rangle\n\nHere, m = frac1N sum_i m_i where m_i is given by magnetization_state and N is given by StochasticSeriesExpansion.normalization_site_count.\n\nType parameters\n\nOrderingVector: Fourier component to compute in units of π. For example (11) corresponds to (ππ)\nIf StaggerUC is true, the sublattice sign of the unitcell is additionally taken into account\nModel: model type to apply this estimator on\nPrefix: (Symbol) this prefix is added to all observable names. Consider magest_standard_prefix.\n\n\n\n\n\n","category":"type"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.magnetization_state","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.magnetization_state","text":"magnetization_state(model::AbstractModel, site_idx, state_idx)\n\nThis interface needs to be implemented by any model that wants to use MagnetizationEstimator. \n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.magnetization_lattice_site_idx","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.magnetization_lattice_site_idx","text":"magnetization_lattice_site_idx(model::AbstractModel, sse_site_idx) -> Integer\n\nIn models where additional degrees of freedom exist, this function maps sse site indices to physical lattice site indices.\n\n\n\n\n\n","category":"function"},{"location":"abstract_opstring_estimator.html#StochasticSeriesExpansion.magest_standard_prefix","page":"OpstringEstimator interface","title":"StochasticSeriesExpansion.magest_standard_prefix","text":"magest_standard_prefix(q::Tuple{Bool...}, stagger_uc::Bool)\n\nReturns the conventional prefix for a magnetization estimator with ordering vector q and stagger_uc set.\n\n\n\n\n\n","category":"function"},{"location":"index.html#StochasticSeriesExpansion.jl","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"An implementation of the stochastic series expansion (SSE) quantum Monte Carlo algorithm for Julia.","category":"page"},{"location":"index.html#Features","page":"StochasticSeriesExpansion.jl","title":"Features","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Run high-performance SSE simulations without being a QMC expert\nSupports anisotropic spin-S quantum Magnets out of the box\nExtensible to arbitrary models (although mind the sign problem)","category":"page"},{"location":"index.html#Getting-started","page":"StochasticSeriesExpansion.jl","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Jump right into the Tutorial (TODO).","category":"page"},{"location":"index.html#Can-I-simulate-my-own-model?","page":"StochasticSeriesExpansion.jl","title":"Can I simulate my own model?","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"All you need to implement is the AbstractModel interface. How well the algorithm performs in the end, depends on the model, in particular if there is a sign problem. Feel free to reach out (e.g. on Github) for assistance!","category":"page"},{"location":"abstract_model.html#abstract_model","page":"Model interface","title":"Model interface","text":"","category":"section"},{"location":"abstract_model.html","page":"Model interface","title":"Model interface","text":"To simulate your own model, all you have to do is to implement the AbstractModel interface.","category":"page"},{"location":"abstract_model.html","page":"Model interface","title":"Model interface","text":"AbstractModel\nStochasticSeriesExpansion.generate_sse_data\nStochasticSeriesExpansion.normalization_site_count\nStochasticSeriesExpansion.get_opstring_estimators","category":"page"},{"location":"abstract_model.html#StochasticSeriesExpansion.AbstractModel","page":"Model interface","title":"StochasticSeriesExpansion.AbstractModel","text":"The type used to define Models that can be simulated by StochasticSeriesExpansion. See StochasticSeriesExpansion.Models.Magnet for a reference implementation.\n\n\n\n\n\n","category":"type"},{"location":"abstract_model.html#StochasticSeriesExpansion.generate_sse_data","page":"Model interface","title":"StochasticSeriesExpansion.generate_sse_data","text":"generate_sse_data(model::AbstractModel) -> SSEData\n\nThis function is responsible for generating an SSEData instance for model. It should use the data saved in the model to construct the information needed by the SSE algorithm, such as the bonds, their connection, and the Hamiltonians acting on each bond.\n\n\n\n\n\n","category":"function"},{"location":"abstract_model.html#StochasticSeriesExpansion.normalization_site_count","page":"Model interface","title":"StochasticSeriesExpansion.normalization_site_count","text":"normalization_site_count(model::AbstractModel) -> Int\n\nThe number of physical sites count used for normalizing observables. It may differ from the SSE algorithmic site count sometimes, e.g. when the computational basis consists of multiple sites but we still want e.g. our energy to be measured per spin.\n\n\n\n\n\n","category":"function"},{"location":"abstract_model.html#StochasticSeriesExpansion.get_opstring_estimators","page":"Model interface","title":"StochasticSeriesExpansion.get_opstring_estimators","text":"get_opstring_estimators(model::AbstractModel) -> Vector{Type{<:AbstractOpstringEstimator}}\n\nReturns an array of types of operator string estimators that are used to calculate most observables. Each of them should implement the AbstractOpstringEstimator interface.\n\n\n\n\n\n","category":"function"}]
}
