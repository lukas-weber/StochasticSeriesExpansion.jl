var documenterSearchIndex = {"docs":
[{"location":"interfaces.html#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"This page lists the different interfaces that need to be implemented to run StochasticSeriesExpansion.jl with custom models or estimators. Their purpose is to translate the information of a physical model into a representation that the SSE algorithm can understand.","category":"page"},{"location":"interfaces.html#abstract_model","page":"Interfaces","title":"Model interface","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"The AbstractModel model interface describes a Hamiltonian that can be simulated with StochasticSeriesExpansion.jl. See Available models to see the available example implementations. ","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"AbstractModel\nStochasticSeriesExpansion.generate_sse_data\nStochasticSeriesExpansion.get_opstring_estimators\nStochasticSeriesExpansion.leg_count\nStochasticSeriesExpansion.normalization_site_count","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.AbstractModel","page":"Interfaces","title":"StochasticSeriesExpansion.AbstractModel","text":"The type used to define models that can be simulated by StochasticSeriesExpansion.jl.\n\nModels are expected to have a constructor\n\nYourModel(parameters::AbstractDict{Symbol, <:Any})\n\nthat gets passed the Carlo.jl task parameters that can be used to describe all parameters of your model, such as the lattice or the coupling strengths.\n\nApart from this, methods for the following functions should be implemented:\n\ngenerate_sse_data\nget_opstring_estimators\nleg_count\nnormalization_site_count\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.generate_sse_data","page":"Interfaces","title":"StochasticSeriesExpansion.generate_sse_data","text":"generate_sse_data(model::YourModel) -> SSEData\n\nThis function should translate the data saved in the model to construct the information needed by the abstract-loop SSE algorithm:\n\na graph of bonds\nthe bond Hamiltonians\n\nFrom this information an SSEData instance can be constructed and returned.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.get_opstring_estimators","page":"Interfaces","title":"StochasticSeriesExpansion.get_opstring_estimators","text":"get_opstring_estimators(model::YourModel) -> Vector{Type{<:AbstractOpstringEstimator}}\n\nReturns an array of types of operator string estimators that are used to calculate most observables. Each of them should implement the Operator string estimator interface.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.leg_count","page":"Interfaces","title":"StochasticSeriesExpansion.leg_count","text":"leg_count(model::Type{YourModel}) -> Integer\n\nThis function returns the maximum number of legs a bond operator can have in the model.\n\nIn the SSE algorithm, the Hamiltonian is decomposed into bond operators that (ideally) act on only a few sites. For example, the Heisenberg model consists of operators that act on two sites. In a diagrammatic picture, each site corresponds to one incoming and one outgoing leg. Therefore, the leg count in the Heisenberg model is four.\n\nOperators with differing leg-counts are supported within the same model. In such cases, leg_count should return the maximum.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.normalization_site_count","page":"Interfaces","title":"StochasticSeriesExpansion.normalization_site_count","text":"normalization_site_count(model::YourModel) -> Integer\n\nThe number of physical sites used for normalizing observables. It may differ from the SSE algorithmic site count sometimes, e.g. when the computational basis consists of multiple physical spins but we still want the energy to be measured per spin.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#abstract_opstring_estimator","page":"Interfaces","title":"Operator string estimator interface","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"The AbstractOpstringEstimator interface is used to implement most observable estimators in StochasticSeriesExpansion.jl.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"AbstractOpstringEstimator\nStochasticSeriesExpansion.init\nStochasticSeriesExpansion.measure\nStochasticSeriesExpansion.result\nStochasticSeriesExpansion.register_evaluables","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.AbstractOpstringEstimator","page":"Interfaces","title":"StochasticSeriesExpansion.AbstractOpstringEstimator","text":"This interface allows defining observable estimators that act on each operator of the the SSE operator string. The measurement code will call the functions of this interface like the following. However, for efficiency reasons, multiple estimators are automatically fused into a single loop.\n\nest = init(YourEstimator, model, state)\nfor op in operators\n    if isidentity(op)\n        continue\n    end\n\n    if !isdiagonal(op)\n        # update state\n    end\n\n    if n < num_operators\n        measure(est, op, state, sse_data)\n    end\n    n += 1\nend\n\nresult(est, mccontext, T, sign)\n\nHowever, in practice, StochasticSeriesExpansion will interlace different estimators into the same loop for efficiency.\n\nA reference implementation is in the model-generic MagnetizationEstimator, which can be used for most magnetization-like observables.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.init","page":"Interfaces","title":"StochasticSeriesExpansion.init","text":"init(::Type{YourOpstringEstimator},\n     model::AbstractModel,\n     state::AbstractVector{<:StateIndex}) -> YourOpstringEstimator\n\nConstructs an opstring estimator based on a model and an initial state. The state is a vector of integers labelling the computational site basis states. The estimator needs to interpret them in terms of physical quantities.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.measure","page":"Interfaces","title":"StochasticSeriesExpansion.measure","text":"measure(est, op::OperCode, state::AbstractVector{<:StateIndex}, sse_data::SSEData)\n\nPerform the in-string measurement of estimator est on each operator op in the operator string. The state at the current position and the sse_data object are passed for additional reference.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.result","page":"Interfaces","title":"StochasticSeriesExpansion.result","text":"result(est, ctx::Carlo.MCContext, T::AbstractFloat, sign::AbstractFloat)\n\nFinalize the measurement by saving the results to the Carlo MCContext, e.g. by calling measure!(ctx, :Magnetization, est.mag). For more information, consult the Carlo documentation.\n\nFor some observables, knowing the temperature T is necessary. In the case of a signful simulation, sign != 1 should be taken into account.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.register_evaluables","page":"Interfaces","title":"StochasticSeriesExpansion.register_evaluables","text":"register_evaluables(\n    ::Type{<:YourOpstringEstimator},\n    eval::AbstractEvaluator,\n    params::AbstractDict\n)\n\nOperator string estimators est can define their own evaluables using this function, which passes a AbstractEvaluator and the task parameters. The state of the estimator is unavailable here since this runs in the postprocessing step.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#MagnetizationEstimator","page":"Interfaces","title":"MagnetizationEstimator","text":"","category":"section"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"A useful general purpose implementation of the operator string estimator interface is the MagnetizationEstimator which works for all models that have some kind of magnetization.","category":"page"},{"location":"interfaces.html","page":"Interfaces","title":"Interfaces","text":"MagnetizationEstimator\nmagnetization_state\nmagnetization_lattice_site_idx\nmagnetization_estimator_standard_prefix","category":"page"},{"location":"interfaces.html#StochasticSeriesExpansion.MagnetizationEstimator","page":"Interfaces","title":"StochasticSeriesExpansion.MagnetizationEstimator","text":"MagnetizationEstimator{\n    OrderingVector,\n    StaggerUC,\n    Model,\n    Prefix} <: AbstractOpstringEstimator\n\nGeneric operator string estimator that can be used for all models that have\n\na field lattice::Lattice\nimplement magnetization_state.\n\noptionally, magnetization_lattice_site_idx.\n\nIt computes the\n\n:Mag, magnetization langle mrangle\n:AbsMag, absolute magnetization langle mrangle\n:Mag2, squared magnetization langle m^2rangle\n:Mag4, quartic magnetization langle m^4rangle\n:MagChi, susceptibility N int_0^beta dtau langle m(tau) mrangle\n:BinderRatio, Binder ratio langle m^2rangle^2langle m^4rangle\n\nHere, m = frac1N sum_i m_i, the m_i are given by magnetization_state and N is returned by normalization_site_count.\n\nType parameters\n\nOrderingVector: Fourier component to compute in units of π. For example (11) corresponds to (ππ)\nIf StaggerUC is true, the sublattice sign of the unitcell is additionally taken into account.\nModel: model type to apply this estimator to.\nPrefix: (Symbol) this prefix is added to all observable names. Consider using magnetization_estimator_standard_prefix.\n\n\n\n\n\n","category":"type"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_state","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_state","text":"magnetization_state(model::AbstractModel, ::Val{Tag}, site_idx, state_idx) where {Tag}\n\nReturns the magnetization at site site_idx for the state state_idx. Tag can be used to dispatch on different “kinds” of magnetization in models that have more than one relevant quantum number per site.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_lattice_site_idx","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_lattice_site_idx","text":"magnetization_lattice_site_idx(model::AbstractModel, sse_site_idx) -> Integer\n\nIn models where additional degrees of freedom exist, this function maps sse site indices to physical lattice site indices.\n\n\n\n\n\n","category":"function"},{"location":"interfaces.html#StochasticSeriesExpansion.magnetization_estimator_standard_prefix","page":"Interfaces","title":"StochasticSeriesExpansion.magnetization_estimator_standard_prefix","text":"magnetization_estimator_standard_prefix(q::Tuple{Bool...}, stagger_uc::Bool)\n\nReturns the conventional prefix for a magnetization estimator with ordering vector q and stagger_uc set.\n\n\n\n\n\n","category":"function"},{"location":"sse_data.html#Simulation-data-structure","page":"Simulation data structure","title":"Simulation data structure","text":"","category":"section"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"In order to be generic, StochasticSeriesExpansion.jl internally uses data structures that do not know a lot about physics but retain only the necessary information to run the SSE algorithm.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"If you want to implement your own models or measurements, you have to translate physics into into an SSEData object.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEData\nget_vertex_data","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEData","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEData","text":"SSEData(vertex_data::AbstractVector{<:VertexData}, bonds::AbstractVector{<:SSEBond})\n\nThis object holds everything StochasticSeriesExpansion needs to know to simulate a model using the abstract loop algorithm.\n\nThe array vertex_data contains one instance of VertexData for each distinct type of bond. The bonds define the graph of bonds along with the corresponding bond types.\n\nPublic fields\n\nbonds: the bond information passed on construction\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_vertex_data","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_vertex_data","text":"get_vertex_data(data::SSEData, bond_idx) -> VertexData\n\nThe VertexData object for a given SSE bond index bond_idx.\n\n\n\n\n\n","category":"function"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"To construct an SSEData object you need to assemble the VertexData and SSEBond objects.","category":"page"},{"location":"sse_data.html","page":"Simulation data structure","title":"Simulation data structure","text":"SSEBond\nVertexData\nget_leg_state","category":"page"},{"location":"sse_data.html#StochasticSeriesExpansion.SSEBond","page":"Simulation data structure","title":"StochasticSeriesExpansion.SSEBond","text":"SSEBond(type, (i, j, ...))\n\nDefines a bond for the SSE algorithm. The type specifies which VertexData object to use. i, j are two or more site indices that are connected by a bond. This number is variable but has to be consistent across the model. If the model has bonds with different number of sites, dummy sites can be used to express lower order bonds.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.VertexData","page":"Simulation data structure","title":"StochasticSeriesExpansion.VertexData","text":"VertexData(dims::Tuple{Integer...}, bond_hamiltonian::AbstractMatrix; \n           energy_offset_factor = 0.25, tolerance = 1e-7, lp_tolerance = 1e-10)\n\nThis object holds the probability tables used for a bond in the abstract loop update algorithm.\n\ndims are the local Hilbert space dimensions of each site of the bond.\n\nbond_hamiltonian is the prod(dims)×prod(dims) matrix describing the bond Hamiltonian in the computational basis. The representation of the product Hilbert space follows the convention of LinearAlgebra.kron, so that if you have site-local operators op1, op2, kron(op1, op2) will give you a correct bond Hamiltonian.\n\nA constant ε is added to the bond hamiltonian so that its smallest diagonal element is\n\nmin_i(h_ii+ε) = alpha times max_i (h_ii) - min_i (h_ii) ge 0\n\nwhere alpha is given by the parameter energy_offset_factor.\n\nMatrix elements smaller tolerance are considered zero. lp_tolerance sets the tolerance for the underlying linear programming problem.\n\n\n\n\n\n","category":"type"},{"location":"sse_data.html#StochasticSeriesExpansion.get_leg_state","page":"Simulation data structure","title":"StochasticSeriesExpansion.get_leg_state","text":"get_leg_state(vd::VertexData, v::VertexCode)\n\nReturns the leg states (matrix elements) of the vertex v as an array of state indices.\n\n\n\n\n\n","category":"function"},{"location":"models.html#available_models","page":"Predefined models","title":"Predefined models","text":"","category":"section"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"This part of the documentation is about the predefined implementations of the model interface that are included with StochasticSeriesExpansion.jl. At the moment there is one such implementation.","category":"page"},{"location":"models.html#MagnetModel","page":"Predefined models","title":"MagnetModel","text":"","category":"section"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"The MagnetModel implementation allows the simulation of Heisenberg-type magnets on arbitrary lattices.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"StochasticSeriesExpansion.MagnetModel","category":"page"},{"location":"models.html#StochasticSeriesExpansion.MagnetModel","page":"Predefined models","title":"StochasticSeriesExpansion.MagnetModel","text":"MagnetModel <: AbstractModel\n\nDescribes an arbitrary-spin quantum magnet with the Hamiltonian\n\nH = sum_ij J_ij (S_i cdot S_j + (1+d_ij) S_i^z S_j^z) + sum_i h_i S^z_i + D^z_i (S^z_i)^2 + D^x_i (S^x_i)^2\n\nTask parameters\n\nlattice: sets the Lattice\nS: spin magnitude (default: 1//2)\nJ: exchange coupling J_ij\nd: exchange anisotrozy d_ij (default: 0)\nh: magnetic field in z-direction h_i (default: 0)\nD_z: single-ion anisotropy in z-direction D^z_i (default: 0)\nD_x: single-ion anisotropy in x-direction D^x_i (default: 0)\n\nBy default, these are the same for each site or bond. However, they (including :S )can be adjusted to be different across the unit cell using\n\nparameter_map: parameter map that assigns different parameters to different bonds/sites of the unit cell.\n\nFurther parameters:\n\nmeasure: control what observables should be measured. Vector containing a combination of\n:magnetization: measures uniform magnetization\n:staggered_magnetization: measures bipartite staggered (antiferromagnetic) magnetization\nany Type{<:AbstractOpstringEstimator} for an implementation of the operator string estimator interface\n\n\n\n\n\n","category":"type"},{"location":"models.html#ClusterModel","page":"Predefined models","title":"ClusterModel","text":"","category":"section"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"warning: Warning\nThis feature is experimental. It is tested and should work, but its API and parameters may change significantly in a future release.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"StochasticSeriesExpansion.ClusterModel\nStochasticSeriesExpansion.ClusterBasis\nStochasticSeriesExpansion.ClusterBases","category":"page"},{"location":"models.html#StochasticSeriesExpansion.ClusterModel","page":"Predefined models","title":"StochasticSeriesExpansion.ClusterModel","text":"ClusterModel <: AbstractModel\n\nThis model wraps another model, allowing to simulate that model in a cluster basis. For example, given a MagnetModel, ClusterModel can be used to reformulate it in the eigenbasis of local dimers, which allows performing SSE simulations for some frustrated models without a sign problem.\n\nFor now, the interface for this is experimental and makes some assumptions on the underlying model, such as having a lattice field. By default, the cluster basis contains all the spins in that lattices unitcell.\n\nTask parameters\n\ninner_model: The underlying AbstractModel that should be simulated\ncluster_bases: Tuple of ClusterBasis to use for the different clusters\nmeasure_quantum_numbers: Vector of named tuples (;name::Symbol, quantum_number::Int) that allows measuring the quantum numbers defined in the ClusterBasis.\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.ClusterBasis","page":"Predefined models","title":"StochasticSeriesExpansion.ClusterBasis","text":"ClusterBasis(quantum_numbers::Vector{NTuple{N,T}}, transformation::AbstractMatrix{T})\n\nSets up a cluster basis with a set of quantum_numbers and a unitary transformation that contains the basis states expressed in the original basis as columns. Each state can be associated with a tuple of quantum numbers (e.g. magnetization or total spin). The length of quantum_numbers has to equal the number of columns in transformation.\n\nFor examples, see the ClusterBases submodule.\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.ClusterBases","page":"Predefined models","title":"StochasticSeriesExpansion.ClusterBases","text":"This submodule contains some useful predefined cluster bases.\n\n\n\n\n\n","category":"module"},{"location":"models.html#Common-ingredients","page":"Predefined models","title":"Common ingredients","text":"","category":"section"},{"location":"models.html#Lattice","page":"Predefined models","title":"Lattice","text":"","category":"section"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"This is a simple lattice structure that may be shared across different models. Practitioners only need to know how to create lattices from the task parameters.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"StochasticSeriesExpansion.Lattice\nStochasticSeriesExpansion.UnitCell\nStochasticSeriesExpansion.UCSite\nStochasticSeriesExpansion.UCBond\nStochasticSeriesExpansion.UnitCells","category":"page"},{"location":"models.html#StochasticSeriesExpansion.Lattice","page":"Predefined models","title":"StochasticSeriesExpansion.Lattice","text":"Lattice{D}\n\nThis is a model-agnostic implementation of a D-dimensional lattice. It allows generating translation symmetric bond graph based on minimal information derived from a unit cell object.\n\nTask parameters\n\nFrom the job file, lattices are specified using a lattice parameter.\n\ntm.lattice = (\n    unitcell = StochasticSeriesExpansion.UnitCells.honeycomb,\n    size = (10,10),\n)\n\nThe unitcell should be an instance of UnitCell and size specifies how many copies of the unit cell in each dimension make up the supercell. The above example creates a honeycomb lattice with 2times 10times 10 sites.\n\nPublic fields\n\nuc: underlying UnitCell object\nLs: tuple of lattice lengths\nbonds: array of LatticeBond.\nsite: array of LatticeSite, useful for quickly converting linear site indices to spatial ones.\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.UnitCell","page":"Predefined models","title":"StochasticSeriesExpansion.UnitCell","text":"UnitCell{D}\n\nThe unit cell used to build a D-dimensional lattice. It can be specified\n\nUnitCell(\n    lattice_vectors::SMatrix{D,D,Float64},\n    sites::AbstractVector{UCSite{D}},\n    bonds::AbstractVector{UCBond{D}}\n)\n\nThe columns of lattice_vector are the lattice vectors. sites and bonds define the connections within and out of the unit cell.\n\nExample\n\nOne of the predefined unitcells in UnitCells is defined as\n\nconst honeycomb = UnitCell(\n    [[sqrt(3) / 2, -0.5] [sqrt(3 / 2), 0.5]],\n    [UCSite((0.0, 0.0)), UCSite((1 / 3, 1 / 3))],\n    [UCBond(1, (0, 0), 2), UCBond(2, (0, 1), 1), UCBond(2, (1, 0), 1)],\n)\n\nRefer the the documentation of UCSite and UCBond for more information.\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.UCSite","page":"Predefined models","title":"StochasticSeriesExpansion.UCSite","text":"UCSite{D}\n\nDefines a site within the unit cell. Construct it using\n\nUCSite(pos::Tuple)\n\npos contains the position of the site inside the unit cell in the lattice vector basis.\n\nPublic fields:\n\npos: see above\ncoordination: coordination number of the site\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.UCBond","page":"Predefined models","title":"StochasticSeriesExpansion.UCBond","text":"UCBond{D}\n\nDefines a unit cell bond between site i and j. Construct it using\n\nUCBond(iuc, jd, juc)\n\niuc is the intra-unit-cell index of i. jd = (jdx, jdy, ...) are the D (nonnegative) offsets of the unit cell containing j with respect to the one containing i. juc is the intra-unit-cell index of j. For examples, see UnitCells.\n\nThese parameters are accessible as public fields as well.\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.UnitCells","page":"Predefined models","title":"StochasticSeriesExpansion.UnitCells","text":"The UnitCells submodule provides some predefined unitcells that can be used to construct lattices.\n\nCurrently there are:\n\nsquare: square lattice\ncolumnar_dimer: square lattice of dimers\nhoneycomb: honeycomb lattice\ntriangle: triangle lattice\n\nThe source code of these is a great starting point if you want to define your own.\n\n\n\n\n\n","category":"module"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"The following are internal pieces of the lattice structure that are useful for model implementers.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"StochasticSeriesExpansion.LatticeSite\nStochasticSeriesExpansion.LatticeBond","category":"page"},{"location":"models.html#StochasticSeriesExpansion.LatticeSite","page":"Predefined models","title":"StochasticSeriesExpansion.LatticeSite","text":"LatticeSite{D}\n\nInformation about a lattice site, locating its position inside the lattice.\n\nPublic fields\n\niuc: index within the unit cell\nix: D-tuple of indices of the unit cell along the lattice dimensions\n\n\n\n\n\n","category":"type"},{"location":"models.html#StochasticSeriesExpansion.LatticeBond","page":"Predefined models","title":"StochasticSeriesExpansion.LatticeBond","text":"LatticeBond\n\nInformation about a lattice bond.\n\nPublic fields\n\ntype: translation symmetry equivalence class of the bond (does not take other symmetries into account!)\ni, j: sites connected by the bond\n\nnote: Note\nIn contrast to SSEBond, LatticeBond only supports 2-site bonds at this point.\n\n\n\n\n\n","category":"type"},{"location":"models.html#parameter_maps","page":"Predefined models","title":"Parameter maps","text":"","category":"section"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"By default, model parameters like the exchange coupling J of the MagnetModel are equal for all bonds in the unit cell. Parameter maps are a way to override this behavior and assign different parameters to different unit cell positions.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"The following example sets different values for the parameter J in the x and y direction.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"using Carlo.JobTools\nusing StochasticSeriesExpansion\n\ntm = TaskMaker()\ntm.model = MagnetModel\ntm.lattice = (;\n    UnitCells.square,\n)\n\ntm.parameter_map = (;\n    J = (:Jx, :Jy)\n)\n\ntm.Jx = 1.0\ntm.Jy = 0.5","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"The length and order of the tuple (:Jx, :Jy) is tied to the way the bonds are specified in the unitcell structure UnitCells.square. In a similar way, one can change site-properties such as h or S by referring to the different sites in the unit cell.","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"using Carlo.JobTools\nusing StochasticSeriesExpansion\n\ntm = TaskMaker()\ntm.model = MagnetModel\ntm.lattice = (;\n    UnitCells.honeycomb,\n)\n\ntm.parameter_map = (;\n    J = (:J1, :J2, :J3),\n    S = (:Sa, :Sb),\n)\n\ntm.J1 = 1.0\ntm.J2 = 0.5\ntm.J3 = 1.5\n\ntm.Sa = 1//2\ntm.Sb = 1","category":"page"},{"location":"models.html","page":"Predefined models","title":"Predefined models","text":"The above example specifies a honeycomb lattice with spin-1/2 on one sublattice and spin-1 on the other. The three directions of nearest-neighbor exchange interactions have different strengths.","category":"page"},{"location":"index.html#StochasticSeriesExpansion.jl","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"An implementation of the stochastic series expansion (SSE) quantum Monte Carlo algorithm for Julia.","category":"page"},{"location":"index.html#Features","page":"StochasticSeriesExpansion.jl","title":"Features","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Run high-performance SSE simulations without being a QMC expert\nSupports anisotropic spin-S quantum magnets out of the box\nExtensible to arbitrary models (but may suffer from sign problem)","category":"page"},{"location":"index.html#Getting-started","page":"StochasticSeriesExpansion.jl","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Jump right into the Tutorial.","category":"page"},{"location":"index.html#Can-I-simulate-my-own-model?","page":"StochasticSeriesExpansion.jl","title":"Can I simulate my own model?","text":"","category":"section"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Yes, by implementing the AbstractModel interface, which requires you the graph of bonds and arbitrary bond operators that describe your Hamiltonian. A key ingredient of the implementation is the “abstract loop” algorithm which will automatically figure out a set of worm updates (which is traditionally choosen by hand). How well the algorithm performs in practice depends on the model, in particular if there is a sign problem. So far it has been applied to","category":"page"},{"location":"index.html","page":"StochasticSeriesExpansion.jl","title":"StochasticSeriesExpansion.jl","text":"Heisenberg-type magnets with various anisotropic terms in the single-site S^z basis\nFrustrated Heisenberg magnets in multi-site bases\nMagnets coupled to cavity photons","category":"page"},{"location":"parameters.html#parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters.html","page":"Parameters","title":"Parameters","text":"The parameters that are given in a StochasticSeriesExpansion.jl job script can be divided into three levels. The first level are parameters read by Carlo.jl, such as sweeps, thermalization and binsize. These are documented in the Carlo.jl documentation. The second level are generic stochastic series expansion (SSE) parameters, which are documented on this page. The third level are model-specific parameters that are documented together with the respective model.","category":"page"},{"location":"parameters.html","page":"Parameters","title":"Parameters","text":"The two required generic SSE level parameters are","category":"page"},{"location":"parameters.html","page":"Parameters","title":"Parameters","text":"T: the temperature of the simulation.\nmodel: the type of the AbstractModel implementation representing the model to be simulated.","category":"page"},{"location":"parameters.html","page":"Parameters","title":"Parameters","text":"Apart from this, there are several optional parameters that control some internal aspects of the SSE simulation. They have reasonable defaults and in the majority of cases do not need to be touched.","category":"page"},{"location":"parameters.html","page":"Parameters","title":"Parameters","text":"init_opstring_cutoff: the initial length of the padded operator string. Will be grown dynamically at runtime. If you see it growing a lot after thermalization, you can give it a higher intial value.\ndiagonal_warmup_sweeps: sometimes loop updates can perform very badly on dilute operator strings that appear in the first steps of the simulation. For this reason, a number of diagonal sweeps are performed at initialization before the first loop update. This parameter sets that number.\ninit_num_worms: the number of worms or loops that should be formed per sweep is adjusted automatically by a simple controller loop. This is the starting value. Should not be less than one.\nnum_worms_attenuation_factor: factor that sets the sensitivity of the worm number control loop. Higher values equilibrate quicker, but are more susceptible to noise.\ntarget_worm_length_fraction: the goal of the controller is to perform enough worm updates so that the combined lengths of the loops they form are target_worm_length_fraction * num_operators.","category":"page"},{"location":"tutorial.html#tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we will calculate the magnetic susceptibility of the spin-1 honeycomb antiferromagnet BaNi₂V₂O₈, reproducing a calculation in PRB 104, 065502 (2021), where an anisotropic Heisenberg model,","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"    H = J sum_ij mathbfS_i cdot mathbfS_j + D^z sum_i (S^z_i)^2","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"was fit to neutron-scattering data. Above, the first sum counts all nearest neighbor bonds (and we neglect next-nearest and next-next-nearest neighbor interactions). However, we do take into account the easy-plane anisotropy D^z to model the split between in-plane and out of plane magnetic susceptibility.","category":"page"},{"location":"tutorial.html#Installation","page":"Tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"As a first step, we need to install StochasticSeriesExpansion.jl and Carlo.jl, which can be done from the Julia REPL.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia>]\npkg> add Carlo\npkg> add StochasticSeriesExpansion","category":"page"},{"location":"tutorial.html#Writing-a-job-script","page":"Tutorial","title":"Writing a job script","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To specify the parameters we want to simulate, we want to write a job script. The following sets up the predefined MagnetModel for our Hamiltonian on a honeycomb lattice and defines tasks for a range of system sizes and temperatures to simulate.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Markdown\npath = \"../../examples/bani2v2o8.jl\"\ncode = open(path, \"r\") do file\n    return read(file, String)\nend\n\nMarkdown.parse(\"```julia\\n$code\\n```\")","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The parameters of this job script control different components of StochasticSeriesExpansion.jl. First are the parameters for Carlo.jl, namely the number of sweeps (Monte Carlo timesteps), the number of thermalization steps and the internal binsize that is averaged before saving data to disk (use it to save disk space, but keep it small compared to sweeps).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Then, T and model set the temperature and the model (Hamiltonian) that should be simulated by StochasticSeriesExpansion.jl. See Parameters for a complete list of parameters at this level. The remainder of the parameters are model parameters, interpreted in this case by the MagnetModel.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"J and Dz which correspond to the parameters in the Hamiltonian, there is the spin magnitude S and the vector measure which decides what kinds of observables should be measured. :magnetization is a shortcut for observables related to the magnetization in S^z direction, including the susceptibility. The meaning of all the model-specific parameters is listed in the documentation of MagnetModel.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The task function takes a snapshot of the current properties of the TaskMaker and turns it into one parameter set to be simulated.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In the JobInfo structure we specify","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"the job directory (splitext(@__FILE__)[1] just evaluates to the location where the job script is saved)\nthat we want to run a simulation with StochasticSeriesExpansion.jl\nthe maximum runtime before the simulation stops\nthe interval between checkpoints\nthe parameter sets (tasks) that should be simulated, created using TaskMaker","category":"page"},{"location":"tutorial.html#Running-the-simulation","page":"Tutorial","title":"Running the simulation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Next we should run it using","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"mpirun -n $NCORES julia bani2v2o8.jl run","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"While you wait, you can run julia bani2v2o8.jl --help for an explanation of the Carlo command line interface.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In general, the computational cost is linear in the number of spins and the inverse temperature. For the system defined here it is small enough to run on a powerful laptop. For larger systems, running on a high-performance computing cluster may be necessary.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once the simulation is done, we will find a new directory bani2v2o8.data and a file bani2v2o8.results.json. The former contains the raw data that was recorded during the simulation and checkpoints, the latter has the postprocessed averages and errorbars of the observables.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"note: Checkpointing\nCarlo.jl automatically creates checkpoints for simulations. This means if it is aborted, it will restart from where it left off. For a finished simulation it is also possible to increase the sweeps and continue it to gather more statistics.This means that to restart a simulation from scratch, it is necessary to first delete the job data,julia $JOBSCRIPT deleteor to run with the restart flagjulia $JOBSCRIPT run --restart","category":"page"},{"location":"tutorial.html#Evaluating-the-results","page":"Tutorial","title":"Evaluating the results","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The Carlo.ResultTools submodule has a tool to directly import the postprocessed data into a Julia dataframe. The following snippet is an example of that.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Plots\nusing DataFrames\nusing LaTeXStrings\nusing Carlo.ResultTools\n\ndf = DataFrame(ResultTools.dataframe(\"bani2v2o8.results.json\"))\n\ndf.L = [lattice[\"size\"][1] for lattice in df.lattice]\n\nplot(df.T, df.MagChi, group=df.L,\n    xlabel = L\"Temperature $T/J$\",\n    ylabel = L\"Magnetic susceptibility $χ^z J$\",\n    legend_title = \"L\"\n)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The dataframe contains all parameters from the job file as well as the observables that were measured. MagChi is the uniform magnetic susceptibility in S^z direction, perpendicular to the easy-plane anisotropy created by D_z. As we can see, the basic shape of the susceptibility (Fig. 3(b) in the paper) is reproduced, but it is not converged to the thermodynamic limit at L=10. We should therefore run larger system sizes until we can assure convergence (the data in the paper is at L=42).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To get the in-plane susceptibility chi^xy, we can simply rotate the anisotropy into the x direction (using the Dx parameter) and run a simulation measuring chi^z again.","category":"page"}]
}
